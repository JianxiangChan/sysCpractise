
# 同步

##4.1几种常见的并发编程错误
---
###error_example1

用临时变量作为线程参数

###error_example2
线程参数共享的问题

##4.2 
**设计目标：**

1. 支持多线程和单线程版本。对于多线程版本，由实现者（在链表）加锁/解锁。对单线程版本，其性能不受影响。
2. 区分单线程和多线程版本的时候，不需要链接不同的库，或者需要宏来控制，完全可以在运行时切换。
3. 保存双向链表的通用性，不依赖于任何平台。

**分析：**

1. 这里要求锁是可以变化的，这就要求我们隔离这种变化。 
2. **接口**只定义调用者和实现者之间的契约，而不规定实现的方法。
3. C语言的接口的朴素定义：一组相关的回调函数和共享的上下文。

**接口需要注意的问题：**

1. 接口一定要抽象
2. 不能有create函数，但是一定要有destory函数。
![](http://i.imgur.com/9l8Z78l.png)

**互斥锁不能嵌套**

##4.3 嵌套锁与装饰模式

###设计目标
* 加锁算法

>1. 如果没有任何线程加锁，则直接加锁，并记录下当前的线程ID
2. 如果当前线程加过锁了，则不用加锁，直接将加锁的计数增加1
3. 如果其他线程加锁了，那就等待直到加锁成功，后继步骤与第一种情况相同

* 解锁算法
>1. 如果不是当前线程的加锁或者没有人的加锁，那这是错误的引用，直接返回
>2. 如果是当前线程加锁了，将加锁计数减1。如果技术仍然大于0，说明当前线程加了多次锁，直接返回就行了。如果当前线程加了一次锁，则执行解锁操作。

###装饰模式
在不改变对象本质（接口）的情况下，给对象添加附加功能。和**继承**不同的是，他不是针对整个类的。
   
其原理如图所示
![](http://images2017.cnblogs.com/blog/1194806/201708/1194806-20170831114132327-1612831059.png)

##4.4 读写锁

###设计目标
* 串行化对数据结构的修改，同时支持并行的查询。
* 不依赖特定平台。
* 任何情况下都不带来额外的性能开销。
###引用计数保护
引用计数保护是十分有必要的，如果没有保护，并发访问会导致在查询计数状态时候，计数被并发的另一线程修改，导致程序加锁解锁错乱。

###读写锁如何才能发挥作用？
* 读的次数远大于写的次数
* 临界区的时间比较长